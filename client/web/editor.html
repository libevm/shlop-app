<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MapleWeb â€” WZ Editor</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: Inter, system-ui, sans-serif; background: #0f172a; color: #e2e8f0; display: flex; height: 100vh; overflow: hidden; font-size: 13px; }

/* â”€â”€â”€ File Browser (Left) â”€â”€â”€ */
#file-panel { width: 260px; background: #1e293b; border-right: 1px solid #334155; display: flex; flex-direction: column; flex-shrink: 0; }
#file-panel .panel-header { padding: 8px 12px; border-bottom: 1px solid #334155; display: flex; gap: 6px; align-items: center; }
#file-panel .panel-header input { flex: 1; background: #0f172a; border: 1px solid #334155; color: #e2e8f0; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
#file-panel .panel-header input:focus { border-color: #3b82f6; outline: none; }
#file-tree { flex: 1; overflow-y: auto; padding: 2px 0; font-size: 12px; }
.tree-node { cursor: pointer; user-select: none; }
.tree-row { display: flex; align-items: center; padding: 2px 4px 2px 0; white-space: nowrap; }
.tree-row:hover { background: #334155; }
.tree-row.selected { background: #1d4ed8; }
.tree-indent { flex-shrink: 0; }
.tree-toggle { width: 16px; height: 16px; display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0; color: #64748b; font-size: 10px; }
.tree-icon { width: 16px; height: 16px; display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0; font-size: 11px; margin-right: 4px; }
.tree-label { overflow: hidden; text-overflow: ellipsis; }
.tree-value { color: #94a3b8; margin-left: 6px; font-size: 11px; max-width: 100px; overflow: hidden; text-overflow: ellipsis; }
.tree-children { display: none; }
.tree-node.open > .tree-children { display: block; }
.ic-folder { color: #eab308; }
.ic-img { color: #3b82f6; }
.ic-canvas { color: #22c55e; }
.ic-int { color: #f97316; }
.ic-string { color: #a78bfa; }
.ic-vector { color: #ec4899; }
.ic-uol { color: #64748b; }
.ic-sound { color: #06b6d4; }

/* â”€â”€â”€ Main Area â”€â”€â”€ */
#main-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

/* â”€â”€â”€ Toolbar â”€â”€â”€ */
#toolbar { height: 36px; background: #1e293b; border-bottom: 1px solid #334155; display: flex; align-items: center; padding: 0 10px; gap: 8px; flex-shrink: 0; }
#toolbar button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-family: inherit; }
#toolbar button:hover { background: #475569; border-color: #3b82f6; }
#toolbar .sep { width: 1px; height: 20px; background: #475569; }
#breadcrumb { font-size: 12px; color: #94a3b8; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
#breadcrumb span { cursor: pointer; color: #60a5fa; }
#breadcrumb span:hover { text-decoration: underline; }

/* â”€â”€â”€ Content Area â”€â”€â”€ */
#content-area { flex: 1; display: flex; overflow: hidden; }

/* â”€â”€â”€ Node Tree (Center) â”€â”€â”€ */
#node-panel { flex: 1; overflow: auto; padding: 8px; }
#node-panel table { width: 100%; border-collapse: collapse; }
#node-panel th { text-align: left; padding: 4px 8px; border-bottom: 1px solid #334155; color: #94a3b8; font-weight: 500; font-size: 11px; text-transform: uppercase; position: sticky; top: 0; background: #0f172a; }
#node-panel td { padding: 3px 8px; border-bottom: 1px solid rgba(51,65,85,0.4); font-size: 12px; vertical-align: top; }
#node-panel tr:hover { background: rgba(51,65,85,0.3); }
#node-panel tr.selected { background: rgba(59,130,246,0.2); }
.cell-name { font-weight: 500; }
.cell-type { color: #64748b; font-size: 11px; }
.cell-value { font-family: monospace; font-size: 12px; max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.cell-value.editable { cursor: text; }
.cell-value.editable:hover { background: rgba(59,130,246,0.15); border-radius: 2px; }
.cell-nav { cursor: pointer; color: #60a5fa; }
.cell-nav:hover { text-decoration: underline; }

/* â”€â”€â”€ Preview Panel (Right) â”€â”€â”€ */
#preview-panel { width: 300px; background: #1e293b; border-left: 1px solid #334155; display: flex; flex-direction: column; flex-shrink: 0; overflow-y: auto; }
#preview-panel h3 { font-size: 12px; padding: 8px 12px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #334155; }
#preview-image { padding: 12px; text-align: center; background: repeating-conic-gradient(#1a1a2e 0% 25%, #0f172a 0% 50%) 50% / 16px 16px; min-height: 60px; }
#preview-image img { max-width: 100%; image-rendering: pixelated; }
#preview-image .empty { color: #475569; font-size: 12px; padding: 20px; }
#preview-props { padding: 8px 12px; }
.preview-row { display: flex; justify-content: space-between; padding: 2px 0; font-size: 12px; }
.preview-row .pk { color: #94a3b8; }
.preview-row .pv { color: #e2e8f0; font-family: monospace; }

/* â”€â”€â”€ Inline edit â”€â”€â”€ */
.inline-edit { background: #0f172a; border: 1px solid #3b82f6; color: #e2e8f0; padding: 1px 4px; font-size: 12px; font-family: monospace; border-radius: 2px; outline: none; width: 200px; }

/* â”€â”€â”€ Status â”€â”€â”€ */
#status-bar { height: 22px; background: #1e293b; border-top: 1px solid #334155; display: flex; align-items: center; padding: 0 12px; font-size: 11px; color: #64748b; gap: 16px; flex-shrink: 0; }
</style>
</head>
<body>

<div id="file-panel">
  <div class="panel-header">
    <input id="file-search" type="text" placeholder="Search files...">
  </div>
  <div id="file-tree"></div>
</div>

<div id="main-area">
  <div id="toolbar">
    <button id="btn-import">ğŸ“‚ Import</button>
    <button id="btn-export">ğŸ’¾ Export</button>
    <div class="sep"></div>
    <button id="btn-back">â† Back</button>
    <div id="breadcrumb"></div>
  </div>
  <div id="content-area">
    <div id="node-panel"></div>
    <div id="preview-panel">
      <h3>Preview</h3>
      <div id="preview-image"><div class="empty">No image</div></div>
      <h3>Properties</h3>
      <div id="preview-props"></div>
    </div>
  </div>
  <div id="status-bar">
    <span id="status-info">Browse WZ files on the left</span>
  </div>
</div>

<input type="file" id="file-import" accept=".json" style="display:none">

<script type="module">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MapleWeb WZ Editor
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const fileTreeEl = document.getElementById("file-tree");
const fileSearchEl = document.getElementById("file-search");
const nodePanelEl = document.getElementById("node-panel");
const previewImageEl = document.getElementById("preview-image");
const previewPropsEl = document.getElementById("preview-props");
const breadcrumbEl = document.getElementById("breadcrumb");
const statusEl = document.getElementById("status-info");

// â”€â”€â”€ State â”€â”€â”€
const jsonCache = new Map();
let navStack = [];      // [{ path, node, label }]
let currentNode = null;
let currentPath = "";
let selectedChild = null;
let fileIndex = null;    // { directories, files } from listing

// â”€â”€â”€ JSON Fetch â”€â”€â”€
async function fetchJson(path) {
  if (jsonCache.has(path)) return jsonCache.get(path);
  const resp = await fetch(`/${path}`);
  if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
  const data = await resp.json();
  jsonCache.set(path, data);
  return data;
}

// â”€â”€â”€ WZ Node Helpers â”€â”€â”€
function nodeChildren(node) {
  if (!node || !node.$$) return [];
  return node.$$;
}

function childName(child) {
  return child.$imgdir ?? child.$canvas ?? child.$int ?? child.$string ??
    child.$float ?? child.$vector ?? child.$uol ?? child.$sound ?? "?";
}

function childType(child) {
  if (child.$imgdir !== undefined) return "imgdir";
  if (child.$canvas !== undefined) return "canvas";
  if (child.$int !== undefined) return "int";
  if (child.$string !== undefined) return "string";
  if (child.$float !== undefined) return "float";
  if (child.$vector !== undefined) return "vector";
  if (child.$uol !== undefined) return "uol";
  if (child.$sound !== undefined) return "sound";
  return "unknown";
}

function childValue(child) {
  const type = childType(child);
  switch (type) {
    case "int": case "string": case "float": case "uol": return child.value;
    case "vector": return `(${child.x}, ${child.y})`;
    case "canvas": return `${child.width}Ã—${child.height}`;
    case "imgdir": return `[${(child.$$ ?? []).length} children]`;
    case "sound": return child.value ?? "(sound)";
    default: return "";
  }
}

function childIcon(type) {
  const icons = { imgdir: "ğŸ“", canvas: "ğŸ–¼", int: "#", string: "T", float: ".", vector: "â†—", uol: "ğŸ”—", sound: "ğŸ”Š" };
  const cls = { imgdir: "ic-folder", canvas: "ic-canvas", int: "ic-int", string: "ic-string", float: "ic-int", vector: "ic-vector", uol: "ic-uol", sound: "ic-sound" };
  return `<span class="tree-icon ${cls[type] ?? ""}">${icons[type] ?? "?"}</span>`;
}

function isNavigable(child) {
  const type = childType(child);
  return type === "imgdir" || type === "canvas";
}

function isEditable(child) {
  const type = childType(child);
  return type === "int" || type === "string" || type === "float" || type === "uol";
}

function isVector(child) { return childType(child) === "vector"; }

// â”€â”€â”€ File Tree â”€â”€â”€
const WZ_DIRS = [
  "Map.wz", "Mob.wz", "Npc.wz", "Reactor.wz", "Character.wz",
  "Item.wz", "Skill.wz", "Sound.wz", "String.wz", "UI.wz",
  "Effect.wz", "Etc.wz", "Base.wz", "TamingMob.wz"
];

async function buildFileTree() {
  fileTreeEl.innerHTML = '<div style="padding:12px;color:#64748b;">Loading file index...</div>';
  
  // Build tree from WZ directories
  let html = "";
  for (const dir of WZ_DIRS) {
    html += `<div class="tree-node" data-dir="${dir}">
      <div class="tree-row" data-action="toggle-dir" data-dir="${dir}">
        <span class="tree-toggle">â–¶</span>
        <span class="tree-icon ic-folder">ğŸ“¦</span>
        <span class="tree-label">${dir}</span>
      </div>
      <div class="tree-children" id="dir-${dir.replace(".", "-")}"></div>
    </div>`;
  }
  fileTreeEl.innerHTML = html;

  fileTreeEl.addEventListener("click", handleFileTreeClick);
}

async function handleFileTreeClick(e) {
  const row = e.target.closest("[data-action]");
  if (!row) return;

  const action = row.dataset.action;
  if (action === "toggle-dir") {
    const dir = row.dataset.dir;
    const node = row.closest(".tree-node");
    const childrenEl = node.querySelector(".tree-children");
    
    if (node.classList.contains("open")) {
      node.classList.remove("open");
      row.querySelector(".tree-toggle").textContent = "â–¶";
      return;
    }

    node.classList.add("open");
    row.querySelector(".tree-toggle").textContent = "â–¼";

    if (childrenEl.children.length === 0) {
      childrenEl.innerHTML = '<div style="padding:4px 24px;color:#64748b;font-size:11px;">Loading...</div>';
      try {
        const listing = await fetchJson(`resources/${dir}`);
        // listing might be a directory listing or a JSON file directly
        // Try to enumerate .img.json files
        const files = await discoverFiles(dir);
        let fhtml = "";
        for (const file of files) {
          fhtml += `<div class="tree-row" data-action="open-file" data-path="resources/${dir}/${file}" style="padding-left:24px;">
            <span class="tree-icon ic-img">ğŸ“„</span>
            <span class="tree-label">${file}</span>
          </div>`;
        }
        childrenEl.innerHTML = fhtml || '<div style="padding:4px 24px;color:#64748b;font-size:11px;">No files found</div>';
      } catch {
        childrenEl.innerHTML = '<div style="padding:4px 24px;color:#64748b;font-size:11px;">Could not list directory</div>';
      }
    }
  } else if (action === "open-file") {
    const path = row.dataset.path;
    await openFile(path);
    // Highlight
    for (const r of fileTreeEl.querySelectorAll(".tree-row.selected")) r.classList.remove("selected");
    row.classList.add("selected");
  }
}

async function discoverFiles(dir) {
  // Try fetching a directory listing by convention
  // The dev server serves static files â€” we'll try fetching an index or known patterns
  try {
    const resp = await fetch(`/resources/${dir}/`);
    if (resp.ok) {
      const text = await resp.text();
      // Try to parse as JSON array or HTML directory listing
      try {
        const arr = JSON.parse(text);
        if (Array.isArray(arr)) return arr.filter(f => f.endsWith(".json")).sort();
      } catch {}
      // Parse HTML links
      const matches = [...text.matchAll(/href="([^"]+\.img\.json)"/g)].map(m => m[1]);
      if (matches.length > 0) return matches.sort();
    }
  } catch {}

  // Fallback: try known file patterns
  const known = await tryKnownFiles(dir);
  return known;
}

async function tryKnownFiles(dir) {
  // For Map.wz, scan subdirectories
  if (dir === "Map.wz") {
    const subs = ["Map/Map0","Map/Map1","Map/Map2","Map/Map3","Map/Map4","Map/Map5",
      "Map/Map6","Map/Map7","Map/Map8","Map/Map9","Back","Obj","Tile","Physics.img.json",
      "MapHelper.img.json"];
    const files = [];
    for (const sub of subs) {
      if (sub.endsWith(".json")) { files.push(sub); continue; }
      try {
        const resp = await fetch(`/resources/${dir}/${sub}/`);
        if (resp.ok) {
          const text = await resp.text();
          try {
            const arr = JSON.parse(text);
            if (Array.isArray(arr)) {
              for (const f of arr) {
                if (f.endsWith(".json")) files.push(`${sub}/${f}`);
              }
            }
          } catch {
            const matches = [...text.matchAll(/href="([^"]+\.json)"/g)].map(m => m[1]);
            for (const m of matches) files.push(`${sub}/${m}`);
          }
        }
      } catch {}
    }
    return files.sort();
  }

  // Generic: try to list directory
  try {
    const resp = await fetch(`/resources/${dir}/`);
    if (resp.ok) {
      const text = await resp.text();
      try {
        const arr = JSON.parse(text);
        if (Array.isArray(arr)) return arr.filter(f => f.endsWith(".json")).sort();
      } catch {}
    }
  } catch {}
  return [];
}

// â”€â”€â”€ Open File â”€â”€â”€
async function openFile(path) {
  statusEl.textContent = `Loading ${path}...`;
  try {
    const data = await fetchJson(path);
    navStack = [{ path, node: data, label: path.split("/").pop() }];
    currentNode = data;
    currentPath = path;
    renderNode();
    statusEl.textContent = `${path} â€” ${(data.$$ ?? []).length} children`;
  } catch (err) {
    statusEl.textContent = `Failed: ${err.message}`;
  }
}

// â”€â”€â”€ Navigation â”€â”€â”€
function navigateTo(child, name) {
  navStack.push({ path: currentPath + "/" + name, node: child, label: name });
  currentNode = child;
  selectedChild = null;
  renderNode();
}

function navigateBack() {
  if (navStack.length <= 1) return;
  navStack.pop();
  const top = navStack[navStack.length - 1];
  currentNode = top.node;
  selectedChild = null;
  renderNode();
}

function navigateToIndex(idx) {
  while (navStack.length > idx + 1) navStack.pop();
  const top = navStack[navStack.length - 1];
  currentNode = top.node;
  selectedChild = null;
  renderNode();
}

// â”€â”€â”€ Render Current Node â”€â”€â”€
function renderNode() {
  renderBreadcrumb();
  renderTable();
  selectChildPreview(null);
}

function renderBreadcrumb() {
  let html = "";
  for (let i = 0; i < navStack.length; i++) {
    if (i > 0) html += " <span style='color:#475569'>/</span> ";
    html += `<span data-nav="${i}">${navStack[i].label}</span>`;
  }
  breadcrumbEl.innerHTML = html;
  for (const span of breadcrumbEl.querySelectorAll("span[data-nav]")) {
    span.addEventListener("click", () => navigateToIndex(Number(span.dataset.nav)));
  }
}

function renderTable() {
  const children = nodeChildren(currentNode);
  if (children.length === 0) {
    nodePanelEl.innerHTML = '<div style="padding:20px;color:#64748b;">Empty node (no children)</div>';
    return;
  }

  let html = `<table><thead><tr><th>Name</th><th>Type</th><th>Value / Size</th></tr></thead><tbody>`;
  
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    const name = childName(child);
    const type = childType(child);
    const value = childValue(child);
    const nav = isNavigable(child);
    const edit = isEditable(child);
    const vec = isVector(child);

    html += `<tr data-idx="${i}">`;
    html += `<td class="cell-name">${childIcon(type)}`;
    if (nav) html += `<span class="cell-nav" data-action="nav" data-idx="${i}">${escHtml(String(name))}</span>`;
    else html += escHtml(String(name));
    html += `</td>`;
    html += `<td class="cell-type">${type}</td>`;
    html += `<td class="cell-value${edit ? " editable" : ""}"`;
    if (edit) html += ` data-action="edit" data-idx="${i}"`;
    html += `>`;
    if (vec) {
      html += `<span class="editable" data-action="edit-vec-x" data-idx="${i}">x: ${child.x}</span>, `;
      html += `<span class="editable" data-action="edit-vec-y" data-idx="${i}">y: ${child.y}</span>`;
    } else {
      html += escHtml(String(value ?? ""));
    }
    html += `</td></tr>`;
  }

  html += `</tbody></table>`;
  nodePanelEl.innerHTML = html;

  // Event delegation
  nodePanelEl.addEventListener("click", handleTableClick);
}

function handleTableClick(e) {
  const el = e.target.closest("[data-action]");
  if (!el) {
    // Row selection
    const tr = e.target.closest("tr[data-idx]");
    if (tr) {
      const idx = Number(tr.dataset.idx);
      for (const r of nodePanelEl.querySelectorAll("tr.selected")) r.classList.remove("selected");
      tr.classList.add("selected");
      selectChildPreview(nodeChildren(currentNode)[idx]);
    }
    return;
  }

  const action = el.dataset.action;
  const idx = Number(el.dataset.idx);
  const children = nodeChildren(currentNode);
  const child = children[idx];

  if (action === "nav") {
    navigateTo(child, childName(child));
  } else if (action === "edit") {
    startInlineEdit(el, child, "value");
  } else if (action === "edit-vec-x") {
    startInlineEdit(el, child, "x");
  } else if (action === "edit-vec-y") {
    startInlineEdit(el, child, "y");
  }
}

function startInlineEdit(el, child, field) {
  const current = field === "value" ? child.value : child[field];
  const input = document.createElement("input");
  input.className = "inline-edit";
  input.value = current ?? "";
  el.textContent = "";
  el.appendChild(input);
  input.focus();
  input.select();

  const commit = () => {
    const raw = input.value;
    const type = childType(child);
    let val = raw;
    if (type === "int" || field === "x" || field === "y") val = parseInt(raw, 10);
    else if (type === "float") val = parseFloat(raw);
    if (Number.isNaN(val)) val = raw;

    child[field] = val;
    renderNode();
    statusEl.textContent = `Updated ${childName(child)}.${field} = ${val}`;
  };

  input.addEventListener("blur", commit);
  input.addEventListener("keydown", e => {
    if (e.key === "Enter") { e.preventDefault(); commit(); }
    if (e.key === "Escape") { renderNode(); }
  });
}

// â”€â”€â”€ Preview Panel â”€â”€â”€
function selectChildPreview(child) {
  selectedChild = child;
  
  // Image preview
  if (child && childType(child) === "canvas" && child.basedata) {
    previewImageEl.innerHTML = `<img src="data:image/png;base64,${child.basedata}">`;
  } else if (child && childType(child) === "imgdir") {
    // Look for a canvas child (frame 0, or direct canvas)
    const canvasChild = (child.$$ ?? []).find(c => c?.$canvas !== undefined && c.basedata);
    const frame0 = (child.$$ ?? []).find(c => c?.$imgdir === "0" || c?.$canvas === "0");
    const target = canvasChild ?? frame0;
    if (target?.basedata) {
      previewImageEl.innerHTML = `<img src="data:image/png;base64,${target.basedata}">`;
    } else if (frame0) {
      // frame0 might be an imgdir containing a canvas
      const inner = (frame0.$$ ?? []).find(c => c?.basedata);
      if (inner?.basedata) previewImageEl.innerHTML = `<img src="data:image/png;base64,${inner.basedata}">`;
      else previewImageEl.innerHTML = '<div class="empty">No image</div>';
    } else {
      previewImageEl.innerHTML = '<div class="empty">No image</div>';
    }
  } else {
    previewImageEl.innerHTML = '<div class="empty">No image</div>';
  }

  // Properties
  if (!child) {
    previewPropsEl.innerHTML = '<div style="color:#475569;font-size:12px;padding:4px 0;">Click a row to preview</div>';
    return;
  }

  let html = "";
  const type = childType(child);
  html += `<div class="preview-row"><span class="pk">Name</span><span class="pv">${escHtml(String(childName(child)))}</span></div>`;
  html += `<div class="preview-row"><span class="pk">Type</span><span class="pv">${type}</span></div>`;

  if (type === "canvas") {
    html += `<div class="preview-row"><span class="pk">Size</span><span class="pv">${child.width} Ã— ${child.height}</span></div>`;
    // Show sub-properties
    for (const sub of child.$$ ?? []) {
      if (!sub) continue;
      const st = childType(sub);
      const sn = childName(sub);
      if (st === "vector") html += `<div class="preview-row"><span class="pk">${sn}</span><span class="pv">(${sub.x}, ${sub.y})</span></div>`;
      else if (st === "int" || st === "string" || st === "float") html += `<div class="preview-row"><span class="pk">${sn}</span><span class="pv">${sub.value}</span></div>`;
    }
  } else if (type === "vector") {
    html += `<div class="preview-row"><span class="pk">x</span><span class="pv">${child.x}</span></div>`;
    html += `<div class="preview-row"><span class="pk">y</span><span class="pv">${child.y}</span></div>`;
  } else if (type === "imgdir") {
    const cc = (child.$$ ?? []).length;
    html += `<div class="preview-row"><span class="pk">Children</span><span class="pv">${cc}</span></div>`;
    // Show leaf values
    for (const sub of (child.$$ ?? []).slice(0, 20)) {
      if (!sub) continue;
      const st = childType(sub);
      if (st === "int" || st === "string" || st === "float") {
        html += `<div class="preview-row"><span class="pk">${childName(sub)}</span><span class="pv">${sub.value}</span></div>`;
      } else if (st === "vector") {
        html += `<div class="preview-row"><span class="pk">${childName(sub)}</span><span class="pv">(${sub.x}, ${sub.y})</span></div>`;
      }
    }
  } else {
    html += `<div class="preview-row"><span class="pk">Value</span><span class="pv">${escHtml(String(childValue(child)))}</span></div>`;
  }

  previewPropsEl.innerHTML = html;
}

// â”€â”€â”€ Import / Export â”€â”€â”€
document.getElementById("btn-import").addEventListener("click", () => {
  document.getElementById("file-import").click();
});

document.getElementById("file-import").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const data = JSON.parse(reader.result);
      const path = `imported/${file.name}`;
      jsonCache.set(path, data);
      navStack = [{ path, node: data, label: file.name }];
      currentNode = data;
      currentPath = path;
      renderNode();
      statusEl.textContent = `Imported ${file.name}`;
    } catch (err) {
      statusEl.textContent = `Import failed: ${err.message}`;
    }
  };
  reader.readAsText(file);
  e.target.value = "";
});

document.getElementById("btn-export").addEventListener("click", () => {
  if (!currentNode) { statusEl.textContent = "Nothing to export"; return; }
  // Export the root of the current file
  const root = navStack[0]?.node ?? currentNode;
  const name = navStack[0]?.label ?? "export.json";
  const blob = new Blob([JSON.stringify(root, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = name.endsWith(".json") ? name : name + ".json";
  a.click();
  URL.revokeObjectURL(url);
  statusEl.textContent = `Exported ${name}`;
});

document.getElementById("btn-back").addEventListener("click", navigateBack);

// â”€â”€â”€ Search â”€â”€â”€
fileSearchEl.addEventListener("input", () => {
  const q = fileSearchEl.value.toLowerCase().trim();
  for (const row of fileTreeEl.querySelectorAll("[data-action='open-file']")) {
    const path = row.dataset.path.toLowerCase();
    row.style.display = !q || path.includes(q) ? "" : "none";
  }
});

// â”€â”€â”€ Keyboard â”€â”€â”€
document.addEventListener("keydown", e => {
  if (e.target.tagName === "INPUT") return;
  if (e.key === "Backspace" || (e.key === "ArrowLeft" && e.altKey)) {
    navigateBack();
    e.preventDefault();
  }
});

// â”€â”€â”€ Utils â”€â”€â”€
function escHtml(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

// â”€â”€â”€ Init â”€â”€â”€
buildFileTree();
</script>
</body>
</html>
